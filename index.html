<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mind Map Studio - Cloud Synced</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .animate-pulse { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyAREf7cLuVnm_hAoOfSPg8Ffuwbq5Vazwk",
            authDomain: "mindmap-app-cb1f7.firebaseapp.com",
            databaseURL: "https://mindmap-app-cb1f7-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "mindmap-app-cb1f7",
            storageBucket: "mindmap-app-cb1f7.firebasestorage.app",
            messagingSenderId: "899953173069",
            appId: "1:899953173069:web:f3f4e0988445cea4b1b204"
        };

        // Initialize Firebase
        const app = firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        const auth = firebase.auth();
        const provider = new firebase.auth.GoogleAuthProvider();

        const Icon = ({ name, size = 20, className = "" }) => {
            const icons = {
                plus: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>,
                trash: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>,
                save: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>,
                folder: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>,
                download: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>,
                upload: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>,
                edit: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>,
                check: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="20 6 9 17 4 12"/></svg>,
                x: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>,
                zoomIn: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></svg>,
                zoomOut: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/></svg>,
                cloud: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"/></svg>,
                cloudOff: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 15h9a5 5 0 0 0 1.7-.3"/><line x1="1" y1="1" x2="23" y2="23"/></svg>
            };
            return <span className={className}>{icons[name]}</span>;
        };

        const MindMapApp = () => {
            const [maps, setMaps] = useState([]);
            const [currentMap, setCurrentMap] = useState(null);
            const [nodes, setNodes] = useState([]);
            const [connections, setConnections] = useState([]);
            const [selectedNode, setSelectedNode] = useState(null);
            const [draggingNode, setDraggingNode] = useState(null);
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
            const [editingNode, setEditingNode] = useState(null);
            const [editText, setEditText] = useState('');
            const [showMapList, setShowMapList] = useState(false);
            const [mapName, setMapName] = useState('Untitled Map');
            const [isEditingName, setIsEditingName] = useState(false);
            const [zoom, setZoom] = useState(1);
            const [pan, setPan] = useState({ x: 0, y: 0 });
            const [isPanning, setIsPanning] = useState(false);
            const [panStart, setPanStart] = useState({ x: 0, y: 0 });
            const [user, setUser] = useState(null);
            const [userProfile, setUserProfile] = useState({ name: '', photo: '' });
            const [syncStatus, setSyncStatus] = useState('connecting');
            const [authReady, setAuthReady] = useState(false);
            const [authError, setAuthError] = useState('');
            const canvasRef = useRef(null);
            const mapsListenerRef = useRef(null);

            useEffect(() => {
                setSyncStatus('connecting');
                const unsubscribe = auth.onAuthStateChanged((firebaseUser) => {
                    setAuthError('');
                    if (firebaseUser) {
                        setUser(firebaseUser);
                        setUserProfile({
                            name: firebaseUser.displayName || '',
                            photo: firebaseUser.photoURL || ''
                        });
                        loadMapsFromFirebase(firebaseUser.uid);
                    } else {
                        setUser(null);
                        setUserProfile({ name: '', photo: '' });
                        if (mapsListenerRef.current) {
                            mapsListenerRef.current.off();
                            mapsListenerRef.current = null;
                        }
                        setMaps([]);
                        setCurrentMap(null);
                        setNodes([]);
                        setConnections([]);
                        setMapName('Untitled Map');
                        setSelectedNode(null);
                        setEditingNode(null);
                        setDraggingNode(null);
                        setShowMapList(false);
                        setPan({ x: 0, y: 0 });
                        setPanStart({ x: 0, y: 0 });
                        setZoom(1);
                        setSyncStatus('signedOut');
                    }
                    setAuthReady(true);
                });

                return () => {
                    unsubscribe();
                    if (mapsListenerRef.current) {
                        mapsListenerRef.current.off();
                        mapsListenerRef.current = null;
                    }
                };
            }, []);

            const loadFromLocalStorage = () => {
                const savedMaps = JSON.parse(localStorage.getItem('mindMaps') || '[]');
                setMaps(savedMaps);
                if (savedMaps.length > 0) {
                    loadMap(savedMaps[0]);
                } else {
                    initializeNewMap();
                }
            };

            const loadMapsFromFirebase = (userId) => {
                if (!userId) return;

                setSyncStatus('connecting');

                if (mapsListenerRef.current) {
                    mapsListenerRef.current.off();
                }

                const mapsRef = database.ref(`users/${userId}/maps`);
                mapsListenerRef.current = mapsRef;

                mapsRef
                    .once('value')
                    .then((snapshot) => {
                        const data = snapshot.val();
                        if (data) {
                            const mapsArray = Object.keys(data)
                                .map(key => {
                                    const mapData = data[key];
                                    // Validate and fix corrupted data
                                    return {
                                        ...mapData,
                                        id: key,
                                        nodes: mapData.nodes || [],
                                        connections: mapData.connections || []
                                    };
                                })
                                .filter(map => map.nodes.length > 0); // Remove empty maps

                            mapsArray.sort((a, b) => new Date(b.lastModified) - new Date(a.lastModified));
                            setMaps(mapsArray);

                            if (mapsArray.length > 0) {
                                loadMap(mapsArray[0]);
                            } else {
                                initializeNewMap();
                            }
                        } else {
                            setMaps([]);
                            initializeNewMap();
                        }
                        setSyncStatus('connected');
                    })
                    .catch((error) => {
                        console.error('Load error:', error);
                        setSyncStatus('error');
                        loadFromLocalStorage();
                    });

                // Listen for changes after initial load
                mapsRef.on('value', (snapshot) => {
                    const data = snapshot.val();
                    if (data) {
                        const mapsArray = Object.keys(data)
                            .map(key => {
                                const mapData = data[key];
                                return {
                                    ...mapData,
                                    id: key,
                                    nodes: mapData.nodes || [],
                                    connections: mapData.connections || []
                                };
                            })
                            .filter(map => map.nodes.length > 0);

                        mapsArray.sort((a, b) => new Date(b.lastModified) - new Date(a.lastModified));
                        setMaps(mapsArray);
                    } else {
                        setMaps([]);
                        initializeNewMap();
                    }
                });
            };

            const initializeNewMap = () => {
                const centerNode = {
                    id: Date.now(),
                    text: 'Central Idea',
                    x: 400,
                    y: 300,
                    color: '#3b82f6',
                    isCenter: true
                };
                setNodes([centerNode]);
                setConnections([]);
                setMapName('Untitled Map');
                setCurrentMap(null);
            };

            const saveMap = async () => {
                if (nodes.length === 0) {
                    alert('Cannot save empty map. Please add at least one node first.');
                    return;
                }

                const mapData = {
                    name: mapName,
                    nodes,
                    connections,
                    lastModified: new Date().toISOString()
                };

                if (user) {
                    setSyncStatus('saving');
                    try {
                        const mapId = currentMap?.id || `map_${Date.now()}`;
                        await database.ref(`users/${user.uid}/maps/${mapId}`).set(mapData);
                        setCurrentMap({ ...mapData, id: mapId });
                        setSyncStatus('synced');
                        setTimeout(() => setSyncStatus('connected'), 2000);
                    } catch (error) {
                        console.error("Save error:", error);
                        setSyncStatus('error');
                        saveToLocalStorage(mapData);
                    }
                } else {
                    saveToLocalStorage(mapData);
                    setSyncStatus('signedOut');
                }
            };

            const saveToLocalStorage = (mapData) => {
                const mapId = currentMap?.id || Date.now();
                const fullMapData = { ...mapData, id: mapId };
                let updatedMaps;
                if (currentMap) {
                    updatedMaps = maps.map(m => m.id === currentMap.id ? fullMapData : m);
                } else {
                    updatedMaps = [...maps, fullMapData];
                }
                setMaps(updatedMaps);
                setCurrentMap(fullMapData);
                localStorage.setItem('mindMaps', JSON.stringify(updatedMaps));
                alert('Saved locally (offline mode)');
            };

            const loadMap = (map) => {
                setCurrentMap(map);
                setNodes(map.nodes || []);
                setConnections(map.connections || []);
                setMapName(map.name || 'Untitled Map');
                setShowMapList(false);
            };

            const deleteMap = async (mapId) => {
                if (!confirm('Are you sure you want to delete this map?')) return;

                if (user) {
                    try {
                        await database.ref(`users/${user.uid}/maps/${mapId}`).remove();
                    } catch (error) {
                        console.error("Delete error:", error);
                        alert('Error deleting map from cloud');
                    }
                }

                const remainingMaps = maps.filter(m => m.id !== mapId);
                setMaps(remainingMaps);
                localStorage.setItem('mindMaps', JSON.stringify(remainingMaps));

                if (currentMap?.id === mapId) {
                    if (remainingMaps.length > 0) {
                        loadMap(remainingMaps[0]);
                    } else {
                        initializeNewMap();
                    }
                }
            };

            const handleSignIn = async () => {
                setSyncStatus('connecting');
                setAuthError('');
                try {
                    await auth.signInWithPopup(provider);
                } catch (error) {
                    console.error('Sign-in error:', error);
                    setSyncStatus('error');
                    setAuthError(error.message || 'Unable to sign in with Google. Please try again.');
                }
            };

            const handleSignOut = async () => {
                setSyncStatus('connecting');
                try {
                    if (mapsListenerRef.current) {
                        mapsListenerRef.current.off();
                        mapsListenerRef.current = null;
                    }
                    await auth.signOut();
                } catch (error) {
                    console.error('Sign-out error:', error);
                    setSyncStatus('error');
                }
            };

            const addNode = () => {
                if (!selectedNode) {
                    alert('Please select a parent node first');
                    return;
                }
                const angle = Math.random() * Math.PI * 2;
                const distance = 150;
                const newNode = {
                    id: Date.now(),
                    text: 'New Node',
                    x: selectedNode.x + Math.cos(angle) * distance,
                    y: selectedNode.y + Math.sin(angle) * distance,
                    color: `hsl(${Math.random() * 360}, 70%, 60%)`,
                    isCenter: false
                };
                setNodes([...nodes, newNode]);
                setConnections([...connections, { from: selectedNode.id, to: newNode.id }]);
            };

            const deleteNode = (nodeId) => {
                const node = nodes.find(n => n.id === nodeId);
                if (node?.isCenter) {
                    alert('Cannot delete the central node');
                    return;
                }
                setNodes(nodes.filter(n => n.id !== nodeId));
                setConnections(connections.filter(c => c.from !== nodeId && c.to !== nodeId));
                setSelectedNode(null);
            };

            const startDragging = (e, node) => {
                if (editingNode) return;
                setDraggingNode(node);
                const rect = canvasRef.current.getBoundingClientRect();
                setDragOffset({
                    x: (e.clientX - rect.left) / zoom - pan.x - node.x,
                    y: (e.clientY - rect.top) / zoom - pan.y - node.y
                });
            };

            const handleMouseMove = (e) => {
                if (draggingNode) {
                    const rect = canvasRef.current.getBoundingClientRect();
                    const newX = (e.clientX - rect.left) / zoom - pan.x - dragOffset.x;
                    const newY = (e.clientY - rect.top) / zoom - pan.y - dragOffset.y;
                    setNodes(nodes.map(n => 
                        n.id === draggingNode.id ? { ...n, x: newX, y: newY } : n
                    ));
                } else if (isPanning) {
                    setPan({
                        x: pan.x + (e.clientX - panStart.x) / zoom,
                        y: pan.y + (e.clientY - panStart.y) / zoom
                    });
                    setPanStart({ x: e.clientX, y: e.clientY });
                }
            };

            const handleMouseUp = () => {
                setDraggingNode(null);
                setIsPanning(false);
            };

            const startEditing = (node) => {
                setEditingNode(node.id);
                setEditText(node.text);
            };

            const saveEdit = () => {
                setNodes(nodes.map(n => 
                    n.id === editingNode ? { ...n, text: editText } : n
                ));
                setEditingNode(null);
            };

            const exportMap = () => {
                const dataStr = JSON.stringify({ name: mapName, nodes, connections }, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `${mapName}.json`;
                link.click();
            };

            const importMap = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            setNodes(data.nodes);
                            setConnections(data.connections);
                            setMapName(data.name);
                            setCurrentMap(null);
                        } catch (error) {
                            alert('Error importing map');
                        }
                    };
                    reader.readAsText(file);
                }
            };

            const startPanning = (e) => {
                if (e.target === canvasRef.current) {
                    setIsPanning(true);
                    setPanStart({ x: e.clientX, y: e.clientY });
                }
            };

            const getSyncIndicator = () => {
                const indicators = {
                    connecting: { icon: 'cloud', color: 'text-yellow-400', text: 'Connecting...', animate: true },
                    connected: { icon: 'cloud', color: 'text-green-400', text: 'Cloud Connected', animate: false },
                    saving: { icon: 'cloud', color: 'text-blue-400', text: 'Saving...', animate: true },
                    synced: { icon: 'cloud', color: 'text-green-400', text: 'Synced ✓', animate: false },
                    signedOut: { icon: 'cloudOff', color: 'text-gray-400', text: 'Sign in to sync', animate: false },
                    error: { icon: 'cloudOff', color: 'text-red-400', text: 'Offline Mode', animate: false }
                };
                const status = indicators[syncStatus] || indicators.connected;
                return (
                    <div className={`flex items-center gap-2 text-xs ${status.color}`}>
                        <span className={status.animate ? 'animate-pulse' : ''}>
                            <Icon name={status.icon} size={16} />
                        </span>
                        <span>{status.text}</span>
                    </div>
                );
            };

            const renderLoginScreen = () => (
                <div className="w-full h-screen bg-gray-900 flex items-center justify-center">
                    <div className="bg-gray-800 border border-gray-700 rounded-2xl p-10 flex flex-col items-center gap-6 shadow-2xl max-w-md text-center">
                        <div className="space-y-2">
                            <h1 className="text-3xl font-bold text-white">Mind Map Studio</h1>
                            <p className="text-gray-300">
                                Sign in with Google to access and sync your mind maps across devices.
                            </p>
                        </div>
                        {authError && (
                            <div className="w-full rounded-lg bg-red-500/10 border border-red-500/40 px-4 py-2 text-sm text-red-300">
                                {authError}
                            </div>
                        )}
                        <button
                            onClick={handleSignIn}
                            className="flex items-center gap-3 px-6 py-3 bg-white text-gray-900 rounded-lg font-semibold hover:bg-gray-100 transition focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900 focus:ring-white"
                        >
                            <img src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" alt="Google" className="w-6 h-6" />
                            Sign in with Google
                        </button>
                        <p className="text-xs text-gray-500">
                            Google authentication is required to use cloud sync.
                        </p>
                    </div>
                </div>
            );

            if (!authReady) {
                return (
                    <div className="w-full h-screen bg-gray-900 flex items-center justify-center text-gray-400">
                        <span>Loading...</span>
                    </div>
                );
            }

            if (!user) {
                return renderLoginScreen();
            }

            return (
                <div className="w-full h-screen bg-gray-900 flex flex-col overflow-hidden">
                    <div className="bg-gray-800 border-b border-gray-700 p-4 flex items-center justify-between flex-wrap gap-2">
                        <div className="flex items-center gap-4">
                            <h1 className="text-2xl font-bold text-white">Mind Map Studio</h1>
                            {isEditingName ? (
                                <div className="flex items-center gap-2">
                                    <input
                                        type="text"
                                        value={mapName}
                                        onChange={(e) => setMapName(e.target.value)}
                                        className="px-3 py-1 bg-gray-700 text-white rounded border border-gray-600"
                                        autoFocus
                                    />
                                    <button onClick={() => setIsEditingName(false)} className="text-green-400 hover:text-green-300">
                                        <Icon name="check" />
                                    </button>
                                </div>
                            ) : (
                                <div className="flex items-center gap-2">
                                    <span className="text-gray-300">{mapName}</span>
                                    <button onClick={() => setIsEditingName(true)} className="text-gray-400 hover:text-gray-300">
                                        <Icon name="edit" size={16} />
                                    </button>
                                </div>
                            )}
                            {getSyncIndicator()}
                        </div>
                        
                        <div className="flex items-center gap-2 flex-wrap">
                            <button onClick={() => setZoom(Math.min(zoom + 0.1, 2))} className="p-2 bg-gray-700 text-white rounded hover:bg-gray-600" title="Zoom In">
                                <Icon name="zoomIn" />
                            </button>
                            <button onClick={() => setZoom(Math.max(zoom - 0.1, 0.5))} className="p-2 bg-gray-700 text-white rounded hover:bg-gray-600" title="Zoom Out">
                                <Icon name="zoomOut" />
                            </button>
                            <span className="text-white px-2">{Math.round(zoom * 100)}%</span>
                            <button onClick={addNode} className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50" disabled={!selectedNode}>
                                <Icon name="plus" />
                                Add Node
                            </button>
                            <button onClick={saveMap} className="flex items-center gap-2 px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700">
                                <Icon name="save" />
                                Save
                            </button>
                            <button onClick={() => setShowMapList(!showMapList)} className="flex items-center gap-2 px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700">
                                <Icon name="folder" />
                                Maps ({maps.length})
                            </button>
                            <button onClick={exportMap} className="p-2 bg-gray-700 text-white rounded hover:bg-gray-600" title="Export">
                                <Icon name="download" />
                            </button>
                            <label className="p-2 bg-gray-700 text-white rounded hover:bg-gray-600 cursor-pointer" title="Import">
                                <Icon name="upload" />
                                <input type="file" accept=".json" onChange={importMap} className="hidden" />
                            </label>
                            <button onClick={initializeNewMap} className="px-4 py-2 bg-gray-700 text-white rounded hover:bg-gray-600">
                                New Map
                            </button>
                            {user && (
                                <button
                                    onClick={async () => {
                                        if (confirm('Clear all cloud data and start fresh? This cannot be undone!')) {
                                            try {
                                                await database.ref(`users/${user.uid}/maps`).remove();
                                                setMaps([]);
                                                initializeNewMap();
                                                alert('Cloud data cleared!');
                                            } catch (error) {
                                                console.error('Error clearing data:', error);
                                                alert('Error clearing data');
                                            }
                                        }
                                    }}
                                    className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 text-sm"
                                    title="Clear all cloud data"
                                >
                                    Reset Cloud
                                </button>
                            )}
                            {user && (
                                <div className="flex items-center gap-3 pl-2 border-l border-gray-700">
                                    {userProfile.photo && (
                                        <img src={userProfile.photo} alt="Profile" className="w-8 h-8 rounded-full border border-gray-600" />
                                    )}
                                    <span className="text-sm text-white max-w-[150px] truncate">
                                        {userProfile.name || user.email || 'Signed In'}
                                    </span>
                                    <button
                                        onClick={handleSignOut}
                                        className="px-3 py-2 bg-gray-700 text-white rounded hover:bg-gray-600"
                                    >
                                        Sign Out
                                    </button>
                                </div>
                            )}
                        </div>
                    </div>

                    {showMapList && (
                        <div className="absolute top-20 right-4 w-80 bg-gray-800 border border-gray-700 rounded-lg shadow-xl z-10 max-h-96 overflow-y-auto">
                            <div className="p-4">
                                <h3 className="text-lg font-bold text-white mb-4">Saved Maps</h3>
                                {maps.length === 0 ? (
                                    <p className="text-gray-400">No saved maps yet</p>
                                ) : (
                                    <div className="space-y-2">
                                        {maps.map(map => (
                                            <div key={map.id} className={`p-3 rounded border ${currentMap?.id === map.id ? 'border-blue-500 bg-gray-700' : 'border-gray-600'} cursor-pointer hover:bg-gray-700`}>
                                                <div className="flex items-center justify-between">
                                                    <div onClick={() => loadMap(map)} className="flex-1">
                                                        <p className="text-white font-medium">{map.name}</p>
                                                        <p className="text-gray-400 text-sm">{new Date(map.lastModified).toLocaleDateString()}</p>
                                                        <p className="text-gray-500 text-xs">{map.nodes.length} nodes</p>
                                                    </div>
                                                    <button onClick={() => deleteMap(map.id)} className="p-2 text-red-400 hover:text-red-300 hover:bg-gray-600 rounded">
                                                        <Icon name="trash" size={16} />
                                                    </button>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </div>
                        </div>
                    )}

                    <div ref={canvasRef} className="flex-1 relative overflow-hidden cursor-move" onMouseMove={handleMouseMove} onMouseUp={handleMouseUp} onMouseDown={startPanning} onMouseLeave={handleMouseUp}>
                        <svg className="absolute inset-0 w-full h-full pointer-events-none">
                            <g transform={`translate(${pan.x * zoom}, ${pan.y * zoom}) scale(${zoom})`}>
                                {connections.map((conn, idx) => {
                                    const fromNode = nodes.find(n => n.id === conn.from);
                                    const toNode = nodes.find(n => n.id === conn.to);
                                    if (!fromNode || !toNode) return null;
                                    return <line key={idx} x1={fromNode.x + 75} y1={fromNode.y + 30} x2={toNode.x + 75} y2={toNode.y + 30} stroke="#4b5563" strokeWidth="2" />;
                                })}
                            </g>
                        </svg>

                        <div className="absolute inset-0" style={{ transform: `translate(${pan.x * zoom}px, ${pan.y * zoom}px) scale(${zoom})`, transformOrigin: '0 0' }}>
                            {nodes.map(node => (
                                <div key={node.id} className={`absolute cursor-move transition-shadow ${selectedNode?.id === node.id ? 'ring-4 ring-yellow-400' : ''} ${node.isCenter ? 'ring-2 ring-white' : ''}`} style={{ left: node.x, top: node.y, backgroundColor: node.color, pointerEvents: 'auto' }} onMouseDown={(e) => { e.stopPropagation(); startDragging(e, node); setSelectedNode(node); }} onClick={(e) => { e.stopPropagation(); setSelectedNode(node); }}>
                                    <div className="px-4 py-2 rounded-lg shadow-lg min-w-[150px] max-w-[250px]">
                                        {editingNode === node.id ? (
                                            <div className="flex items-center gap-2">
                                                <input type="text" value={editText} onChange={(e) => setEditText(e.target.value)} className="flex-1 px-2 py-1 bg-white/20 text-white rounded border-none outline-none" autoFocus onKeyPress={(e) => e.key === 'Enter' && saveEdit()} />
                                                <button onClick={saveEdit} className="text-white hover:text-green-200"><Icon name="check" size={16} /></button>
                                                <button onClick={() => setEditingNode(null)} className="text-white hover:text-red-200"><Icon name="x" size={16} /></button>
                                            </div>
                                        ) : (
                                            <div className="flex items-center justify-between gap-2">
                                                <p className="text-white font-medium text-sm flex-1">{node.text}</p>
                                                <div className="flex gap-1">
                                                    <button onClick={(e) => { e.stopPropagation(); startEditing(node); }} className="text-white hover:text-blue-200 p-1">
                                                        <Icon name="edit" size={14} />
                                                    </button>
                                                    {!node.isCenter && (
                                                        <button onClick={(e) => { e.stopPropagation(); deleteNode(node.id); }} className="text-white hover:text-red-200 p-1">
                                                            <Icon name="trash" size={14} />
                                                        </button>
                                                    )}
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>

                    <div className="bg-gray-800 border-t border-gray-700 p-3 text-sm text-gray-400">
                        <p><strong className="text-white">Instructions:</strong> Click a node to select → Add Node → Drag to move → Edit to rename → Drag canvas to pan | <span className="text-green-400">☁️ Cloud sync enabled - access from any device!</span></p>
                    </div>
                </div>
            );
        };

        ReactDOM.render(<MindMapApp />, document.getElementById('root'));
    </script>
</body>
</html>
