<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mind Map Studio - Cloud Synced</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden;
            touch-action: none;
        }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }
        .animate-pulse { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        .space-cursor { cursor: grab !important; }
        .space-cursor-active { cursor: grabbing !important; }
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
        }
        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        .node-animation {
            animation: nodeAppear 0.3s ease-out;
        }
        @keyframes nodeAppear {
            from { transform: scale(0); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyAREf7cLuVnm_hAoOfSPg8Ffuwbq5Vazwk",
            authDomain: "mindmap-app-cb1f7.firebaseapp.com",
            databaseURL: "https://mindmap-app-cb1f7-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "mindmap-app-cb1f7",
            storageBucket: "mindmap-app-cb1f7.firebasestorage.app",
            messagingSenderId: "899953173069",
            appId: "1:899953173069:web:f3f4e0988445cea4b1b204"
        };

        const app = firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        const auth = firebase.auth();

        const Icon = ({ name, size = 20, className = "" }) => {
            const icons = {
                plus: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>,
                trash: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>,
                save: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>,
                folder: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/></svg>,
                download: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>,
                upload: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>,
                edit: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>,
                check: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><polyline points="20 6 9 17 4 12"/></svg>,
                x: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>,
                zoomIn: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="11" y1="8" x2="11" y2="14"/><line x1="8" y1="11" x2="14" y2="11"/></svg>,
                zoomOut: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/><line x1="8" y1="11" x2="14" y2="11"/></svg>,
                cloud: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"/></svg>,
                cloudOff: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 15h9a5 5 0 0 0 1.7-.3"/><line x1="1" y1="1" x2="23" y2="23"/></svg>,
                sun: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>,
                moon: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>,
                logout: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/><polyline points="16 17 21 12 16 7"/><line x1="21" y1="12" x2="9" y2="12"/></svg>,
                user: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>,
                menu: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><line x1="3" y1="12" x2="21" y2="12"/><line x1="3" y1="6" x2="21" y2="6"/><line x1="3" y1="18" x2="21" y2="18"/></svg>,
                target: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2"/></svg>,
                search: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><circle cx="11" cy="11" r="8"/><line x1="21" y1="21" x2="16.65" y2="16.65"/></svg>,
                undo: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M3 7v6h6"/><path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/></svg>,
                redo: <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2"><path d="M21 7v6h-6"/><path d="M3 17a9 9 0 0 1 9-9 9 9 0 0 1 6 2.3l3 2.7"/></svg>
            };
            return <span className={className}>{icons[name]}</span>;
        };

        const Toast = ({ message, type = 'info', onClose }) => {
            useEffect(() => {
                const timer = setTimeout(onClose, 3000);
                return () => clearTimeout(timer);
            }, []);

            const colors = {
                info: 'bg-blue-500 text-white',
                success: 'bg-green-500 text-white',
                error: 'bg-red-500 text-white',
                warning: 'bg-yellow-500 text-white'
            };

            return (
                <div className={`toast ${colors[type]}`}>
                    {message}
                </div>
            );
        };

        const LoginScreen = ({ onLogin, darkMode, toggleDarkMode }) => {
            const [isLoading, setIsLoading] = useState(false);

            const handleGoogleLogin = async () => {
                setIsLoading(true);
                try {
                    const provider = new firebase.auth.GoogleAuthProvider();
                    await auth.signInWithPopup(provider);
                } catch (error) {
                    console.error("Login error:", error);
                    alert('Login failed: ' + error.message);
                    setIsLoading(false);
                }
            };

            return (
                <div className={`w-full h-screen flex items-center justify-center ${darkMode ? 'bg-gray-900' : 'bg-gray-50'}`}>
                    <div className="absolute top-4 right-4">
                        <button
                            onClick={toggleDarkMode}
                            className={`p-3 rounded-full ${darkMode ? 'bg-gray-800 text-yellow-400 hover:bg-gray-700' : 'bg-white text-gray-700 hover:bg-gray-100'} shadow-lg transition-colors`}
                            title={darkMode ? 'Switch to Light Mode' : 'Switch to Dark Mode'}
                        >
                            <Icon name={darkMode ? 'sun' : 'moon'} size={24} />
                        </button>
                    </div>

                    <div className={`max-w-md w-full mx-4 p-8 rounded-2xl shadow-2xl ${darkMode ? 'bg-gray-800' : 'bg-white'}`}>
                        <div className="text-center mb-8">
                            <div className={`w-20 h-20 mx-auto mb-4 rounded-full flex items-center justify-center ${darkMode ? 'bg-blue-600' : 'bg-blue-500'}`}>
                                <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="white" strokeWidth="2">
                                    <circle cx="12" cy="12" r="3"/>
                                    <path d="M12 1v6m0 6v6m9-9h-6m-6 0H3"/>
                                    <circle cx="18" cy="6" r="2"/>
                                    <circle cx="6" cy="18" r="2"/>
                                    <circle cx="18" cy="18" r="2"/>
                                    <circle cx="6" cy="6" r="2"/>
                                </svg>
                            </div>
                            <h1 className={`text-3xl font-bold mb-2 ${darkMode ? 'text-white' : 'text-gray-900'}`}>
                                Mind Map Studio
                            </h1>
                            <p className={`${darkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                                Create and organize your ideas visually
                            </p>
                        </div>

                        <div className="space-y-4">
                            <button
                                onClick={handleGoogleLogin}
                                disabled={isLoading}
                                className={`w-full flex items-center justify-center gap-3 px-6 py-4 rounded-lg font-medium transition-all ${
                                    darkMode 
                                        ? 'bg-white text-gray-900 hover:bg-gray-100' 
                                        : 'bg-gray-900 text-white hover:bg-gray-800'
                                } disabled:opacity-50 disabled:cursor-not-allowed shadow-lg hover:shadow-xl`}
                            >
                                {isLoading ? (
                                    <div className="w-6 h-6 border-3 border-gray-300 border-t-transparent rounded-full animate-spin"></div>
                                ) : (
                                    <>
                                        <svg width="24" height="24" viewBox="0 0 24 24">
                                            <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                                            <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                                            <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                                            <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                                        </svg>
                                        <span>Continue with Google</span>
                                    </>
                                )}
                            </button>

                            <div className={`text-center text-sm ${darkMode ? 'text-gray-400' : 'text-gray-600'}`}>
                                <p>✨ Cloud sync across all devices</p>
                                <p>🔒 Your data is private and secure</p>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const MindMapApp = () => {
            const [maps, setMaps] = useState([]);
            const [currentMap, setCurrentMap] = useState(null);
            const [nodes, setNodes] = useState([]);
            const [connections, setConnections] = useState([]);
            const [selectedNode, setSelectedNode] = useState(null);
            const [draggingNode, setDraggingNode] = useState(null);
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
            const [editingNode, setEditingNode] = useState(null);
            const [editText, setEditText] = useState('');
            const [showMapList, setShowMapList] = useState(false);
            const [showMobileMenu, setShowMobileMenu] = useState(false);
            const [mapName, setMapName] = useState('Untitled Map');
            const [isEditingName, setIsEditingName] = useState(false);
            const [zoom, setZoom] = useState(1);
            const [pan, setPan] = useState({ x: 0, y: 0 });
            const [isPanning, setIsPanning] = useState(false);
            const [panStart, setPanStart] = useState({ x: 0, y: 0 });
            const [user, setUser] = useState(null);
            const [syncStatus, setSyncStatus] = useState('connecting');
            const [darkMode, setDarkMode] = useState(true);
            const [isAuthChecking, setIsAuthChecking] = useState(true);
            const [spacePressed, setSpacePressed] = useState(false);
            const [history, setHistory] = useState([]);
            const [historyIndex, setHistoryIndex] = useState(-1);
            const [toast, setToast] = useState(null);
            const [searchQuery, setSearchQuery] = useState('');
            const [showSearch, setShowSearch] = useState(false);
            const [autoSaveEnabled, setAutoSaveEnabled] = useState(true);
            const [touchStart, setTouchStart] = useState(null);
            const [touchDistance, setTouchDistance] = useState(null);
            const canvasRef = useRef(null);
            const autoSaveTimerRef = useRef(null);

            useEffect(() => {
                const savedTheme = localStorage.getItem('mindmap_theme');
                if (savedTheme) {
                    setDarkMode(savedTheme === 'dark');
                }

                const savedAutoSave = localStorage.getItem('mindmap_autosave');
                if (savedAutoSave !== null) {
                    setAutoSaveEnabled(savedAutoSave === 'true');
                }

                const unsubscribe = auth.onAuthStateChanged((user) => {
                    setIsAuthChecking(false);
                    if (user) {
                        setUser(user);
                        setSyncStatus('connected');
                        loadMapsFromFirebase(user.uid);
                    } else {
                        setUser(null);
                        setSyncStatus('disconnected');
                    }
                });

                return () => unsubscribe();
            }, []);

            // Space key pan functionality
            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (e.code === 'Space' && !editingNode && !isEditingName) {
                        e.preventDefault();
                        setSpacePressed(true);
                    }
                    // Keyboard shortcuts
                    if (e.ctrlKey || e.metaKey) {
                        if (e.key === 's') {
                            e.preventDefault();
                            saveMap();
                        } else if (e.key === 'z' && !e.shiftKey) {
                            e.preventDefault();
                            undo();
                        } else if (e.key === 'z' && e.shiftKey || e.key === 'y') {
                            e.preventDefault();
                            redo();
                        } else if (e.key === 'f') {
                            e.preventDefault();
                            setShowSearch(true);
                        }
                    }
                    if (e.key === 'Delete' && selectedNode && !selectedNode.isCenter) {
                        deleteNode(selectedNode.id);
                    }
                    if (e.key === 'Escape') {
                        setShowSearch(false);
                        setShowMobileMenu(false);
                        setShowMapList(false);
                    }
                };

                const handleKeyUp = (e) => {
                    if (e.code === 'Space') {
                        setSpacePressed(false);
                    }
                };

                window.addEventListener('keydown', handleKeyDown);
                window.addEventListener('keyup', handleKeyUp);

                return () => {
                    window.removeEventListener('keydown', handleKeyDown);
                    window.removeEventListener('keyup', handleKeyUp);
                };
            }, [editingNode, isEditingName, selectedNode, nodes, connections, historyIndex]);

            // Auto-save functionality
            useEffect(() => {
                if (autoSaveEnabled && nodes.length > 0 && user) {
                    if (autoSaveTimerRef.current) {
                        clearTimeout(autoSaveTimerRef.current);
                    }
                    autoSaveTimerRef.current = setTimeout(() => {
                        saveMap(true);
                    }, 30000); // Auto-save every 30 seconds
                }
                return () => {
                    if (autoSaveTimerRef.current) {
                        clearTimeout(autoSaveTimerRef.current);
                    }
                };
            }, [nodes, connections, mapName, autoSaveEnabled]);

            // Touch gestures for mobile
            const handleTouchStart = (e) => {
                if (e.touches.length === 2) {
                    const distance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    setTouchDistance(distance);
                } else if (e.touches.length === 1) {
                    setTouchStart({ x: e.touches[0].clientX, y: e.touches[0].clientY });
                }
            };

            const handleTouchMove = (e) => {
                if (e.touches.length === 2 && touchDistance) {
                    e.preventDefault();
                    const distance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    const delta = distance - touchDistance;
                    const newZoom = Math.max(0.5, Math.min(2, zoom + delta * 0.01));
                    setZoom(newZoom);
                    setTouchDistance(distance);
                } else if (e.touches.length === 1 && touchStart && !draggingNode) {
                    e.preventDefault();
                    const deltaX = e.touches[0].clientX - touchStart.x;
                    const deltaY = e.touches[0].clientY - touchStart.y;
                    setPan({
                        x: pan.x + deltaX / zoom,
                        y: pan.y + deltaY / zoom
                    });
                    setTouchStart({ x: e.touches[0].clientX, y: e.touches[0].clientY });
                }
            };

            const handleTouchEnd = () => {
                setTouchDistance(null);
                setTouchStart(null);
            };

            const showToast = (message, type = 'info') => {
                setToast({ message, type });
            };

            const saveToHistory = () => {
                const newHistory = history.slice(0, historyIndex + 1);
                newHistory.push({ nodes: [...nodes], connections: [...connections] });
                setHistory(newHistory);
                setHistoryIndex(newHistory.length - 1);
            };

            const undo = () => {
                if (historyIndex > 0) {
                    const prevState = history[historyIndex - 1];
                    setNodes(prevState.nodes);
                    setConnections(prevState.connections);
                    setHistoryIndex(historyIndex - 1);
                    showToast('Undone', 'info');
                }
            };

            const redo = () => {
                if (historyIndex < history.length - 1) {
                    const nextState = history[historyIndex + 1];
                    setNodes(nextState.nodes);
                    setConnections(nextState.connections);
                    setHistoryIndex(historyIndex + 1);
                    showToast('Redone', 'info');
                }
            };

            const toggleDarkMode = () => {
                const newMode = !darkMode;
                setDarkMode(newMode);
                localStorage.setItem('mindmap_theme', newMode ? 'dark' : 'light');
            };

            const toggleAutoSave = () => {
                const newValue = !autoSaveEnabled;
                setAutoSaveEnabled(newValue);
                localStorage.setItem('mindmap_autosave', newValue.toString());
                showToast(`Auto-save ${newValue ? 'enabled' : 'disabled'}`, 'success');
            };

            const centerView = () => {
                const centerNode = nodes.find(n => n.isCenter);
                if (centerNode) {
                    setPan({ x: -centerNode.x + window.innerWidth / 2 / zoom - 75, y: -centerNode.y + window.innerHeight / 2 / zoom - 30 });
                    showToast('View centered', 'success');
                }
            };

            const handleLogout = async () => {
                if (confirm('Are you sure you want to logout?')) {
                    try {
                        await auth.signOut();
                    } catch (error) {
                        console.error('Logout error:', error);
                        showToast('Error logging out', 'error');
                    }
                }
            };

            const loadMapsFromFirebase = (userId) => {
                const mapsRef = database.ref(`users/${userId}/maps`);
                mapsRef.once('value', (snapshot) => {
                    const data = snapshot.val();
                    if (data) {
                        const mapsArray = Object.keys(data).map(key => {
                            const mapData = data[key];
                            return {
                                ...mapData,
                                id: key,
                                nodes: mapData.nodes || [],
                                connections: mapData.connections || []
                            };
                        }).filter(map => map.nodes.length > 0);
                        
                        mapsArray.sort((a, b) => new Date(b.lastModified) - new Date(a.lastModified));
                        setMaps(mapsArray);
                        
                        if (mapsArray.length > 0) {
                            loadMap(mapsArray[0]);
                        } else {
                            initializeNewMap();
                        }
                    } else {
                        initializeNewMap();
                    }
                });
                
                mapsRef.on('value', (snapshot) => {
                    const data = snapshot.val();
                    if (data) {
                        const mapsArray = Object.keys(data).map(key => {
                            const mapData = data[key];
                            return {
                                ...mapData,
                                id: key,
                                nodes: mapData.nodes || [],
                                connections: mapData.connections || []
                            };
                        }).filter(map => map.nodes.length > 0);
                        
                        mapsArray.sort((a, b) => new Date(b.lastModified) - new Date(a.lastModified));
                        setMaps(mapsArray);
                    }
                });
            };

            const initializeNewMap = () => {
                const centerNode = {
                    id: Date.now(),
                    text: 'Central Idea',
                    x: 400,
                    y: 300,
                    color: '#3b82f6',
                    isCenter: true
                };
                setNodes([centerNode]);
                setConnections([]);
                setMapName('Untitled Map');
                setCurrentMap(null);
                setHistory([{ nodes: [centerNode], connections: [] }]);
                setHistoryIndex(0);
            };

            const saveMap = async (isAutoSave = false) => {
                if (nodes.length === 0) {
                    if (!isAutoSave) showToast('Cannot save empty map', 'warning');
                    return;
                }

                const mapData = {
                    name: mapName,
                    nodes,
                    connections,
                    lastModified: new Date().toISOString()
                };

                setSyncStatus('saving');

                if (user) {
                    try {
                        const mapId = currentMap?.id || `map_${Date.now()}`;
                        await database.ref(`users/${user.uid}/maps/${mapId}`).set(mapData);
                        setCurrentMap({ ...mapData, id: mapId });
                        setSyncStatus('synced');
                        if (!isAutoSave) showToast('Map saved successfully', 'success');
                        setTimeout(() => setSyncStatus('connected'), 2000);
                    } catch (error) {
                        console.error("Save error:", error);
                        setSyncStatus('error');
                        showToast('Error saving map', 'error');
                    }
                }
            };

            const loadMap = (map) => {
                setCurrentMap(map);
                setNodes(map.nodes || []);
                setConnections(map.connections || []);
                setMapName(map.name || 'Untitled Map');
                setShowMapList(false);
                setHistory([{ nodes: map.nodes || [], connections: map.connections || [] }]);
                setHistoryIndex(0);
                showToast('Map loaded', 'success');
            };

            const deleteMap = async (mapId) => {
                if (!confirm('Are you sure you want to delete this map?')) return;

                if (user) {
                    try {
                        await database.ref(`users/${user.uid}/maps/${mapId}`).remove();
                        showToast('Map deleted', 'success');
                    } catch (error) {
                        console.error("Delete error:", error);
                        showToast('Error deleting map', 'error');
                    }
                }

                if (currentMap?.id === mapId) {
                    const remainingMaps = maps.filter(m => m.id !== mapId);
                    if (remainingMaps.length > 0) {
                        loadMap(remainingMaps[0]);
                    } else {
                        initializeNewMap();
                    }
                }
            };

            const addNode = () => {
                if (!selectedNode) {
                    showToast('Please select a parent node first', 'warning');
                    return;
                }
                saveToHistory();
                const angle = Math.random() * Math.PI * 2;
                const distance = 150;
                const newNode = {
                    id: Date.now(),
                    text: 'New Node',
                    x: selectedNode.x + Math.cos(angle) * distance,
                    y: selectedNode.y + Math.sin(angle) * distance,
                    color: `hsl(${Math.random() * 360}, 70%, 60%)`,
                    isCenter: false
                };
                setNodes([...nodes, newNode]);
                setConnections([...connections, { from: selectedNode.id, to: newNode.id }]);
                setSelectedNode(newNode);
                showToast('Node added', 'success');
            };

            const deleteNode = (nodeId) => {
                const node = nodes.find(n => n.id === nodeId);
                if (node?.isCenter) {
                    showToast('Cannot delete the central node', 'warning');
                    return;
                }
                saveToHistory();
                setNodes(nodes.filter(n => n.id !== nodeId));
                setConnections(connections.filter(c => c.from !== nodeId && c.to !== nodeId));
                setSelectedNode(null);
                showToast('Node deleted', 'success');
            };

            const startDragging = (e, node) => {
                if (editingNode || spacePressed) return;
                setDraggingNode(node);
                const rect = canvasRef.current.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                setDragOffset({
                    x: (clientX - rect.left) / zoom - pan.x - node.x,
                    y: (clientY - rect.top) / zoom - pan.y - node.y
                });
            };

            const handleMouseMove = (e) => {
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                if (draggingNode) {
                    const rect = canvasRef.current.getBoundingClientRect();
                    const newX = (clientX - rect.left) / zoom - pan.x - dragOffset.x;
                    const newY = (clientY - rect.top) / zoom - pan.y - dragOffset.y;
                    
                    setNodes(nodes.map(n => 
                        n.id === draggingNode.id ? { ...n, x: newX, y: newY } : n
                    ));
                } else if (isPanning || spacePressed) {
                    setPan({
                        x: pan.x + (clientX - panStart.x) / zoom,
                        y: pan.y + (clientY - panStart.y) / zoom
                    });
                    setPanStart({ x: clientX, y: clientY });
                }
            };

            const handleMouseUp = () => {
                if (draggingNode) {
                    saveToHistory();
                }
                setDraggingNode(null);
                setIsPanning(false);
            };

            const startEditing = (node) => {
                setEditingNode(node.id);
                setEditText(node.text);
            };

            const saveEdit = () => {
                saveToHistory();
                setNodes(nodes.map(n => 
                    n.id === editingNode ? { ...n, text: editText } : n
                ));
                setEditingNode(null);
            };

            const exportMap = () => {
                const dataStr = JSON.stringify({ name: mapName, nodes, connections }, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `${mapName}.json`;
                link.click();
                showToast('Map exported', 'success');
            };

            const importMap = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            setNodes(data.nodes);
                            setConnections(data.connections);
                            setMapName(data.name);
                            setCurrentMap(null);
                            saveToHistory();
                            showToast('Map imported', 'success');
                        } catch (error) {
                            showToast('Error importing map', 'error');
                        }
                    };
                    reader.readAsText(file);
                }
            };

            const startPanning = (e) => {
                if (spacePressed || e.target === canvasRef.current) {
                    setIsPanning(true);
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    setPanStart({ x: clientX, y: clientY });
                }
            };

            const searchNodes = () => {
                if (!searchQuery.trim()) return;
                const found = nodes.find(n => n.text.toLowerCase().includes(searchQuery.toLowerCase()));
                if (found) {
                    setSelectedNode(found);
                    setPan({ x: -found.x + window.innerWidth / 2 / zoom - 75, y: -found.y + window.innerHeight / 2 / zoom - 30 });
                    showToast('Node found', 'success');
                } else {
                    showToast('No matching node found', 'warning');
                }
            };

            const getSyncIndicator = () => {
                const indicators = {
                    connecting: { icon: 'cloud', color: 'text-yellow-400', text: 'Connecting...', animate: true },
                    connected: { icon: 'cloud', color: 'text-green-400', text: 'Connected', animate: false },
                    saving: { icon: 'cloud', color: 'text-blue-400', text: 'Saving...', animate: true },
                    synced: { icon: 'cloud', color: 'text-green-400', text: 'Synced ✓', animate: false },
                    error: { icon: 'cloudOff', color: 'text-red-400', text: 'Offline', animate: false }
                };
                const status = indicators[syncStatus] || indicators.connected;
                return (
                    <div className={`flex items-center gap-2 text-xs ${status.color}`}>
                        <span className={status.animate ? 'animate-pulse' : ''}>
                            <Icon name={status.icon} size={16} />
                        </span>
                        <span className="hidden sm:inline">{status.text}</span>
                    </div>
                );
            };

            if (isAuthChecking) {
                return (
                    <div className={`w-full h-screen flex items-center justify-center ${darkMode ? 'bg-gray-900' : 'bg-gray-50'}`}>
                        <div className="text-center">
                            <div className="w-16 h-16 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
                            <p className={darkMode ? 'text-gray-400' : 'text-gray-600'}>Loading...</p>
                        </div>
                    </div>
                );
            }

            if (!user) {
                return <LoginScreen onLogin={() => {}} darkMode={darkMode} toggleDarkMode={toggleDarkMode} />;
            }

            const bgColor = darkMode ? 'bg-gray-900' : 'bg-gray-50';
            const headerBg = darkMode ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200';
            const textPrimary = darkMode ? 'text-white' : 'text-gray-900';
            const textSecondary = darkMode ? 'text-gray-300' : 'text-gray-700';
            const textMuted = darkMode ? 'text-gray-400' : 'text-gray-600';
            const btnBg = darkMode ? 'bg-gray-700 hover:bg-gray-600' : 'bg-gray-200 hover:bg-gray-300';
            const inputBg = darkMode ? 'bg-gray-700 border-gray-600' : 'bg-white border-gray-300';
            const sidebarBg = darkMode ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200';
            const connectionColor = darkMode ? '#4b5563' : '#9ca3af';

            return (
                <div className={`w-full h-screen ${bgColor} flex flex-col overflow-hidden ${spacePressed ? 'space-cursor' : ''} ${isPanning && spacePressed ? 'space-cursor-active' : ''}`}>
                    {/* Header */}
                    <div className={`${headerBg} border-b p-2 sm:p-4 flex items-center justify-between gap-2`}>
                        <div className="flex items-center gap-2 sm:gap-4 flex-1 min-w-0">
                            <button
                                onClick={() => setShowMobileMenu(!showMobileMenu)}
                                className={`p-2 ${btnBg} ${textPrimary} rounded sm:hidden`}
                            >
                                <Icon name="menu" />
                            </button>
                            <h1 className={`text-lg sm:text-2xl font-bold ${textPrimary} truncate`}>Mind Map</h1>
                            {!showMobileMenu && (
                                <>
                                    {isEditingName ? (
                                        <div className="flex items-center gap-2 flex-1 min-w-0">
                                            <input
                                                type="text"
                                                value={mapName}
                                                onChange={(e) => setMapName(e.target.value)}
                                                className={`px-2 py-1 text-sm sm:px-3 sm:py-1 ${inputBg} ${textPrimary} rounded border flex-1 min-w-0`}
                                                autoFocus
                                            />
                                            <button onClick={() => setIsEditingName(false)} className="text-green-400 hover:text-green-300">
                                                <Icon name="check" size={16} />
                                            </button>
                                        </div>
                                    ) : (
                                        <div className="hidden sm:flex items-center gap-2">
                                            <span className={`${textSecondary} truncate max-w-xs`}>{mapName}</span>
                                            <button onClick={() => setIsEditingName(true)} className={textMuted}>
                                                <Icon name="edit" size={16} />
                                            </button>
                                        </div>
                                    )}
                                </>
                            )}
                            <div className="hidden sm:flex">{getSyncIndicator()}</div>
                        </div>
                        
                        {/* Desktop Controls */}
                        <div className="hidden lg:flex items-center gap-2 flex-wrap">
                            <button onClick={toggleDarkMode} className={`p-2 ${btnBg} ${textPrimary} rounded`} title={darkMode ? 'Light Mode' : 'Dark Mode'}>
                                <Icon name={darkMode ? 'sun' : 'moon'} />
                            </button>
                            <button onClick={() => setShowSearch(true)} className={`p-2 ${btnBg} ${textPrimary} rounded`} title="Search (Ctrl+F)">
                                <Icon name="search" />
                            </button>
                            <button onClick={centerView} className={`p-2 ${btnBg} ${textPrimary} rounded`} title="Center View">
                                <Icon name="target" />
                            </button>
                            <button onClick={undo} disabled={historyIndex <= 0} className={`p-2 ${btnBg} ${textPrimary} rounded disabled:opacity-30`} title="Undo (Ctrl+Z)">
                                <Icon name="undo" />
                            </button>
                            <button onClick={redo} disabled={historyIndex >= history.length - 1} className={`p-2 ${btnBg} ${textPrimary} rounded disabled:opacity-30`} title="Redo (Ctrl+Shift+Z)">
                                <Icon name="redo" />
                            </button>
                            <button onClick={() => setZoom(Math.min(zoom + 0.1, 2))} className={`p-2 ${btnBg} ${textPrimary} rounded`} title="Zoom In">
                                <Icon name="zoomIn" />
                            </button>
                            <button onClick={() => setZoom(Math.max(zoom - 0.1, 0.5))} className={`p-2 ${btnBg} ${textPrimary} rounded`} title="Zoom Out">
                                <Icon name="zoomOut" />
                            </button>
                            <span className={`${textPrimary} px-2 text-sm`}>{Math.round(zoom * 100)}%</span>
                            <button onClick={addNode} className="flex items-center gap-2 px-3 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:opacity-50 text-sm" disabled={!selectedNode}>
                                <Icon name="plus" size={18} />
                                <span className="hidden xl:inline">Add</span>
                            </button>
                            <button onClick={() => saveMap(false)} className="flex items-center gap-2 px-3 py-2 bg-green-600 text-white rounded hover:bg-green-700 text-sm">
                                <Icon name="save" size={18} />
                                <span className="hidden xl:inline">Save</span>
                            </button>
                            <button onClick={() => setShowMapList(!showMapList)} className="flex items-center gap-2 px-3 py-2 bg-purple-600 text-white rounded hover:bg-purple-700 text-sm">
                                <Icon name="folder" size={18} />
                                <span className="hidden xl:inline">Maps ({maps.length})</span>
                            </button>
                            <button onClick={exportMap} className={`p-2 ${btnBg} ${textPrimary} rounded`} title="Export">
                                <Icon name="download" />
                            </button>
                            <label className={`p-2 ${btnBg} ${textPrimary} rounded cursor-pointer`} title="Import">
                                <Icon name="upload" />
                                <input type="file" accept=".json" onChange={importMap} className="hidden" />
                            </label>
                            <button onClick={initializeNewMap} className={`px-3 py-2 ${btnBg} ${textPrimary} rounded text-sm`}>
                                New
                            </button>
                            {user.photoURL && (
                                <img src={user.photoURL} alt="Profile" className="w-8 h-8 rounded-full" />
                            )}
                            <button onClick={handleLogout} className={`p-2 ${btnBg} ${textPrimary} rounded`} title="Logout">
                                <Icon name="logout" />
                            </button>
                        </div>

                        {/* Mobile Quick Actions */}
                        <div className="flex lg:hidden items-center gap-2">
                            <button onClick={addNode} className="p-2 bg-blue-600 text-white rounded disabled:opacity-50" disabled={!selectedNode} title="Add Node">
                                <Icon name="plus" size={20} />
                            </button>
                            <button onClick={() => saveMap(false)} className="p-2 bg-green-600 text-white rounded" title="Save">
                                <Icon name="save" size={20} />
                            </button>
                        </div>
                    </div>

                    {/* Mobile Menu */}
                    {showMobileMenu && (
                        <div className={`${sidebarBg} border-b p-4 lg:hidden`}>
                            <div className="grid grid-cols-3 gap-2">
                                <button onClick={() => { setShowMapList(true); setShowMobileMenu(false); }} className={`p-3 ${btnBg} ${textPrimary} rounded text-sm flex flex-col items-center gap-1`}>
                                    <Icon name="folder" />
                                    <span className="text-xs">Maps</span>
                                </button>
                                <button onClick={() => { setShowSearch(true); setShowMobileMenu(false); }} className={`p-3 ${btnBg} ${textPrimary} rounded text-sm flex flex-col items-center gap-1`}>
                                    <Icon name="search" />
                                    <span className="text-xs">Search</span>
                                </button>
                                <button onClick={centerView} className={`p-3 ${btnBg} ${textPrimary} rounded text-sm flex flex-col items-center gap-1`}>
                                    <Icon name="target" />
                                    <span className="text-xs">Center</span>
                                </button>
                                <button onClick={undo} disabled={historyIndex <= 0} className={`p-3 ${btnBg} ${textPrimary} rounded text-sm flex flex-col items-center gap-1 disabled:opacity-30`}>
                                    <Icon name="undo" />
                                    <span className="text-xs">Undo</span>
                                </button>
                                <button onClick={redo} disabled={historyIndex >= history.length - 1} className={`p-3 ${btnBg} ${textPrimary} rounded text-sm flex flex-col items-center gap-1 disabled:opacity-30`}>
                                    <Icon name="redo" />
                                    <span className="text-xs">Redo</span>
                                </button>
                                <button onClick={toggleDarkMode} className={`p-3 ${btnBg} ${textPrimary} rounded text-sm flex flex-col items-center gap-1`}>
                                    <Icon name={darkMode ? 'sun' : 'moon'} />
                                    <span className="text-xs">Theme</span>
                                </button>
                                <button onClick={exportMap} className={`p-3 ${btnBg} ${textPrimary} rounded text-sm flex flex-col items-center gap-1`}>
                                    <Icon name="download" />
                                    <span className="text-xs">Export</span>
                                </button>
                                <label className={`p-3 ${btnBg} ${textPrimary} rounded text-sm flex flex-col items-center gap-1 cursor-pointer`}>
                                    <Icon name="upload" />
                                    <span className="text-xs">Import</span>
                                    <input type="file" accept=".json" onChange={importMap} className="hidden" />
                                </label>
                                <button onClick={handleLogout} className={`p-3 ${btnBg} ${textPrimary} rounded text-sm flex flex-col items-center gap-1`}>
                                    <Icon name="logout" />
                                    <span className="text-xs">Logout</span>
                                </button>
                            </div>
                            <div className="mt-3 flex items-center justify-between">
                                <label className="flex items-center gap-2 cursor-pointer">
                                    <input
                                        type="checkbox"
                                        checked={autoSaveEnabled}
                                        onChange={toggleAutoSave}
                                        className="w-4 h-4"
                                    />
                                    <span className={`text-sm ${textSecondary}`}>Auto-save (30s)</span>
                                </label>
                                <span className={`text-xs ${textMuted}`}>{Math.round(zoom * 100)}%</span>
                            </div>
                        </div>
                    )}

                    {/* Search Bar */}
                    {showSearch && (
                        <div className={`${headerBg} border-b p-4`}>
                            <div className="flex items-center gap-2 max-w-2xl mx-auto">
                                <input
                                    type="text"
                                    placeholder="Search nodes..."
                                    value={searchQuery}
                                    onChange={(e) => setSearchQuery(e.target.value)}
                                    onKeyPress={(e) => e.key === 'Enter' && searchNodes()}
                                    className={`flex-1 px-4 py-2 ${inputBg} ${textPrimary} rounded border`}
                                    autoFocus
                                />
                                <button onClick={searchNodes} className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">
                                    Find
                                </button>
                                <button onClick={() => setShowSearch(false)} className={`p-2 ${btnBg} ${textPrimary} rounded`}>
                                    <Icon name="x" />
                                </button>
                            </div>
                        </div>
                    )}

                    {/* Map List Sidebar */}
                    {showMapList && (
                        <div className={`absolute top-16 sm:top-20 right-4 w-full sm:w-80 ${sidebarBg} border rounded-lg shadow-xl z-10 max-h-96 overflow-y-auto mx-4 sm:mx-0`}>
                            <div className="p-4">
                                <div className="flex items-center justify-between mb-4">
                                    <h3 className={`text-lg font-bold ${textPrimary}`}>Saved Maps</h3>
                                    <button onClick={() => setShowMapList(false)} className={textMuted}>
                                        <Icon name="x" size={20} />
                                    </button>
                                </div>
                                {maps.length === 0 ? (
                                    <p className={textMuted}>No saved maps yet</p>
                                ) : (
                                    <div className="space-y-2">
                                        {maps.map(map => (
                                            <div key={map.id} className={`p-3 rounded border ${currentMap?.id === map.id ? 'border-blue-500' : darkMode ? 'border-gray-600' : 'border-gray-300'} cursor-pointer hover:${darkMode ? 'bg-gray-700' : 'bg-gray-50'}`}>
                                                <div className="flex items-center justify-between">
                                                    <div onClick={() => loadMap(map)} className="flex-1 min-w-0">
                                                        <p className={`${textPrimary} font-medium truncate`}>{map.name}</p>
                                                        <p className={`${textMuted} text-sm`}>{new Date(map.lastModified).toLocaleDateString()}</p>
                                                        <p className={`${textMuted} text-xs`}>{map.nodes.length} nodes</p>
                                                    </div>
                                                    <button onClick={(e) => { e.stopPropagation(); deleteMap(map.id); }} className={`p-2 text-red-400 hover:text-red-300 hover:${darkMode ? 'bg-gray-600' : 'bg-gray-100'} rounded`}>
                                                        <Icon name="trash" size={16} />
                                                    </button>
                                                </div>
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </div>
                        </div>
                    )}

                    {/* Canvas */}
                    <div 
                        ref={canvasRef} 
                        className="flex-1 relative overflow-hidden cursor-move" 
                        onMouseMove={handleMouseMove}
                        onMouseDown={startPanning}
                        onMouseUp={handleMouseUp}
                        onMouseLeave={handleMouseUp}
                        onTouchStart={handleTouchStart}
                        onTouchMove={handleTouchMove}
                        onTouchEnd={handleTouchEnd}
                    >
                        <svg className="absolute inset-0 w-full h-full pointer-events-none">
                            <g transform={`translate(${pan.x * zoom}, ${pan.y * zoom}) scale(${zoom})`}>
                                {connections.map((conn, idx) => {
                                    const fromNode = nodes.find(n => n.id === conn.from);
                                    const toNode = nodes.find(n => n.id === conn.to);
                                    if (!fromNode || !toNode) return null;
                                    return <line key={idx} x1={fromNode.x + 75} y1={fromNode.y + 30} x2={toNode.x + 75} y2={toNode.y + 30} stroke={connectionColor} strokeWidth="2" />;
                                })}
                            </g>
                        </svg>

                        <div className="absolute inset-0" style={{ transform: `translate(${pan.x * zoom}px, ${pan.y * zoom}px) scale(${zoom})`, transformOrigin: '0 0' }}>
                            {nodes.map(node => (
                                <div 
                                    key={node.id} 
                                    className={`absolute cursor-move transition-shadow node-animation ${selectedNode?.id === node.id ? 'ring-4 ring-yellow-400' : ''} ${node.isCenter ? 'ring-2 ring-white' : ''}`} 
                                    style={{ left: node.x, top: node.y, backgroundColor: node.color, pointerEvents: 'auto' }} 
                                    onMouseDown={(e) => { e.stopPropagation(); if (!spacePressed) startDragging(e, node); setSelectedNode(node); }}
                                    onTouchStart={(e) => { e.stopPropagation(); startDragging(e, node); setSelectedNode(node); }}
                                    onClick={(e) => { e.stopPropagation(); setSelectedNode(node); }}
                                >
                                    <div className="px-3 py-2 sm:px-4 sm:py-2 rounded-lg shadow-lg min-w-[120px] sm:min-w-[150px] max-w-[200px] sm:max-w-[250px]">
                                        {editingNode === node.id ? (
                                            <div className="flex items-center gap-2">
                                                <input 
                                                    type="text" 
                                                    value={editText} 
                                                    onChange={(e) => setEditText(e.target.value)} 
                                                    className="flex-1 px-2 py-1 bg-white/20 text-white rounded border-none outline-none text-sm" 
                                                    autoFocus 
                                                    onKeyPress={(e) => e.key === 'Enter' && saveEdit()} 
                                                />
                                                <button onClick={saveEdit} className="text-white hover:text-green-200">
                                                    <Icon name="check" size={14} />
                                                </button>
                                                <button onClick={() => setEditingNode(null)} className="text-white hover:text-red-200">
                                                    <Icon name="x" size={14} />
                                                </button>
                                            </div>
                                        ) : (
                                            <div className="flex items-center justify-between gap-2">
                                                <p className="text-white font-medium text-xs sm:text-sm flex-1">{node.text}</p>
                                                <div className="flex gap-1">
                                                    <button onClick={(e) => { e.stopPropagation(); startEditing(node); }} className="text-white hover:text-blue-200 p-1">
                                                        <Icon name="edit" size={12} />
                                                    </button>
                                                    {!node.isCenter && (
                                                        <button onClick={(e) => { e.stopPropagation(); deleteNode(node.id); }} className="text-white hover:text-red-200 p-1">
                                                            <Icon name="trash" size={12} />
                                                        </button>
                                                    )}
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                </div>
                            ))}
                        </div>
                    </div>

                    {/* Status Bar */}
                    <div className={`${headerBg} border-t p-2 text-xs sm:text-sm ${textMuted}`}>
                        <div className="flex items-center justify-between gap-2">
                            <p className="hidden sm:block">
                                <strong className={textPrimary}>Tip:</strong> Hold <kbd className={`px-2 py-1 ${btnBg} rounded`}>Space</kbd> + drag to pan | <kbd className={`px-2 py-1 ${btnBg} rounded`}>Ctrl+S</kbd> to save
                            </p>
                            <p className="sm:hidden truncate">
                                Hold Space + drag to pan
                            </p>
                            <div className="flex items-center gap-2 sm:gap-4">
                                <label className="hidden sm:flex items-center gap-2 cursor-pointer">
                                    <input
                                        type="checkbox"
                                        checked={autoSaveEnabled}
                                        onChange={toggleAutoSave}
                                        className="w-3 h-3"
                                    />
                                    <span>Auto-save</span>
                                </label>
                                <div className="sm:hidden">{getSyncIndicator()}</div>
                                <span className="text-green-400 truncate max-w-[150px] sm:max-w-none">
                                    {user.displayName || user.email}
                                </span>
                            </div>
                        </div>
                    </div>

                    {/* Toast Notifications */}
                    {toast && <Toast message={toast.message} type={toast.type} onClose={() => setToast(null)} />}
                </div>
            );
        };

        ReactDOM.render(<MindMapApp />, document.getElementById('root'));
    </script>
</body>
</html>
